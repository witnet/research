# Red4Sec security audit: mitigation

|  # | Description       | Risk     | State        |
| -- | ----------------- | -------- | ------------ |
|  1 | [Replay PoI Attack](#1-Replay-PoI-Attack) | CRITICAL | MITIGATED |
|  2 | [Race Condition Transaction Order Dependence](#2-Race-Condition-Transaction-Order-Dependence)     | CRITICAL     | FIXED     |
|  3 | [Drain of Contract Funds that could trigger a Denial of Service](#3-Drain-of-Contract-Funds-that-could-trigger-a-Denial-of-Service)     | CRITICAL     | FIXED |
|  4 | [Denial of Service via Integer Overflow](#4-Denial-of-Service-via-Integer-Overflow)     | HIGH     | FIXED     |
|  5 | [Possible Burn of Funds while updating Data Request](#5-Possible-Burn-of-Funds-while-updating-Data-Request)     | MEDIUM     | FIXED |
|  6 | [Prevent Loss of Funds when interacting with UsingWitnet contract](#6-Prevent-Loss-of-Funds-when-interacting-with-UsingWitnet-contract)     | MEDIUM     | FIXED     |
|  7 | [Witnet Node De-Anonymization](#7-Witnet-Node-De-Anonymization)     | MEDIUM     | OUT OF SCOPE)     |
|  8 | [Bad Implementation of ecAdd algorithm](#8-Bad-Implementation-of-ecAdd-algorithm)     | MEDIUM     | FIXED     |
|  9 | [Multiple Integer Overflows](#9-Multiple-Integer-Overflows)   | LOW     | FIXED     |
| 10 | [Outdated Compiler Version with Known Vulnerabilities](#10-Outdated-Compiler-Version-with-Known-Vulnerabilities)     | LOW     | FIXED     |
| 11 | [Minor Logic Errors](#11-Minor-Logic-Errors) | LOW     | PARTIALLY FIXED     |
| 12 | [Owner Change Implementation](#12-Owner-Change-Implementation)     | LOW     | ASSUMED     |
| 13 | [Absence of Verifications](#13-Absence-of-Verifications)     |  LOW  | PARTIALLY FIXED    |
| 14 | [Not Exploitable Reentrancy](#14-Not-Exploitable-Reentrancy)     | INFORMATIVE     | FIXED     |
| 15 | [Gas optimizations](#15-Gas-optimizations)     | INFORMATIVE     | PARTIALLY FIXED     |
| 16 | [Comments Specification Mismatch](16-Comments-Specification-Mismatch)     | INFORMATIVE     | FIXED     |
| 17 | [Use of Experimental Features](#17-Use-of-Experimental-Features)     | INFORMATIVE     | ASSUMED     |
| 18 | [Solidity Code Readability](#18-solidity-code-readibility)     | INFORMATIVE     | FIXED     |
| 19 | [Provide License for Third-Party Codes](#19-Provide-License-for-Third-Party-Codes) | INFORMATIVE     | FIXED     |


## 1. Replay PoI Attack

State: MITIGATED (partially fixed and residual risk is assumed)

### Recommendations

 - Implement protections against replay attacks.
 - Add the request identifier to the drHash.

### Mitigation

The Red4Sec recommendation of using a request identifier as part of the digest (`drHash`) was discarded due to the following reasons:

 - If the identifier is generated by the Witnet network, the Ethereum smart contract cannot verify the correctness of the ID.
 - If the identifier is generated externally to Witnet, then the problem is that it cannot be guaranteed that the identifiers are unique across time. In other words, the same data request might have been resolved previously with the same ID (e.g. by another chain and/or smart contract) and its associated cryptographic proof could be re-used.

The issue has been mitigated by storing the `epochs` of the complete data request lifecycle.

```solidity
struct DataRequest {
    // [...]
    // The epoch of the block including the last transaction related to the dr
    // (postDataRequest, reportDataRequestInclusion, reportResult)
    uint256 epoch;
}
```

This change ensures that:

- data request posting happens before data request inclusion

    ```solidity
    // Ensures the request inclusion is reported after the epoch in which the request was posted
    require(
        requests[_id].epoch < _epoch,
        "the dr inclusion must be reported after the dr is posted into the WRB"
    );
    ```

- data request inclusion happens before data request resolution

    ```solidity
    require(requests[_id].epoch <= _epoch, "The result cannot be reported before the request is included");
    ```

This fix decreases the attack window to a limited number of epochs because as soon as a data request is posted into the WRB, there should be enough incentives for a bridge node to claim it and post it to Witnet.


Source code available at [PR#90](https://github.com/witnet/witnet-ethereum-bridge/pull/90/).


## 2. Race Condition Transaction Order Dependence

State: FIXED

### Recommendations

 - To avoid this type of attack, it is necessary to include the sender's address in the PoI validation.
 - Sign the address that will receive the funds as it is done in the function `claimDataRequest()`.

### Mitigation

The recommendation would be sufficient to fix the issue but potentially it could allow cases in which the data request successful resolution solely depends on the  claimer for posting it into the Witnet network (e.g. the resolution depends on the claimer availability).

However, a guard must be put in place to prevent malicious miners from performing a "front-running attack". They could get economic rewards without doing any job by copying other transactions with higher fees.

The mitigation consists on a new requirement that only allows entities from the `Active Bridge Set` to report results. There is still a race condition between bridges which only could lead to the request results being included faster into a block.

A modifier has been defined in order to allow only ABS members to report data requests by using the `reportResult` function:

```solidity
// Ensures the address belongs to the active bridge set
modifier absMember(address _address) {
  require(abs.absMembership(_address), "Not a member of the ABS");
  _;
}
```

Source code available at [PR#77](https://github.com/witnet/witnet-ethereum-bridge/pull/77).


## 3. Drain of Contract Funds that could trigger a Denial of Service

State: FIXED

### Recommendations

 - Add a boolean type field in the DataRequest struct as a flag to check whether the result has already been reported or not.

### Mitigation

The recommendation of adding a boolean type was discarded due to the additional storage that this would incur on. Instead, a requirement has been added that checks whether the posted result has zero length.

This is enough for the case of Witnet as results are encoded in CBOR and no result can be encoded with zero bytes in CBOR.

```solidity
// This would not be a valid encoding with CBOR and could trigger a reentrancy attack
require(_result.length != 0, "Result has zero length");
```

Source code available at [PR#79](https://github.com/witnet/witnet-ethereum-bridge/pull/79).


## 4. Denial of Service via Integer Overflow

State: FIXED

### Recommendations

- Perform comparisons between variables of the same type and size.
- Ensure that the processes to accomplish can be executed without exceeding maximum gas limits.

### Mitigation

As recommended, the `for` loops were modified in `flushSlots()` and `pushActivity()` were modified to use variables of the same type and size:

```solidity
for (uint256 id = 0; id < epochIdsLength; id++) {
    // [...]
}
```

The source code is available at [PR#85](https://github.com/witnet/witnet-ethereum-bridge/pull/85).


## 5. Possible Burn of Funds while updating Data Request

State: FIXED

### Recommendations

- Check the request status to evaluate whether revert or not the fee increase, and thus avoid unnecessary loss of ether.

### Mitigation

The recommendation of checking the request status before updating the reward of the data request has been developed. In particular, the following checks have been included:

- If a data request has not yet been included, it allows upgrading both the inclusion and tally rewards.
- If a data request has been included but not resolved, it only allows upgrading the tally reward.
- If a data request has already been resolved, the upgrade method reverts.

```solidity
if (requests[_id].drHash != 0) {
    require(
        msg.value == _tallyReward,
        "Txn value should equal result reward argument (request reward already paid)"
    );
    requests[_id].tallyReward = SafeMath.add(requests[_id].tallyReward, _tallyReward);
} else {
    requests[_id].inclusionReward = SafeMath.add(requests[_id].inclusionReward, msg.value - _tallyReward);
    requests[_id].tallyReward = SafeMath.add(requests[_id].tallyReward, _tallyReward);
}
```

Source code available at [PR#86](https://github.com/witnet/witnet-ethereum-bridge/pull/86).


## 6. Prevent Loss of Funds when interacting with `UsingWitnet` contract

State: FIXED

### Recommendations

- Add a require() verification that forces the `msg.value` to be equal to the sum of the two fees.
- It is suggested to unify the criteria of both contracts, so the `UsingWitnetBytes` mechanism, should be the standard one.
- This change requires modifying the examples `witnet/truffle-box` and `stampery-labs/witnet-pricefeed-example`.


### Mitigation

A modifier function was defined in order to check if the reward amounts are valid in `witnetPostRequest()` and `witnetUpgradeRequest()`:

```solidity
// Ensures that user-specified rewards are equal to the total transaction value to prevent users from burning any excess value
modifier validRewards(uint256 _requestReward, uint256 _resultReward) {
    require(_requestReward + _resultReward >= _requestReward, "The sum of rewards overflows");
    require(msg.value == _requestReward + _resultReward, "Transaction value should equal the sum of rewards");
    _;
}
```

Additionally, `UsingWitnetBytes` contract was removed as it was not being used by any other contract.

Source code available at [PR#86](https://github.com/witnet/witnet-ethereum-bridge/pull/86).


## 7. Witnet Node De-Anonymization

State: OUT OF SCOPE

### Recommendations

- Apply a generic User-Agent in order to avoid or at least make the identification of the nodes by webmasters and attackers more complicated.

### Mitigation

This issue falls out of the smart contracts scope and has no pull request addressing it. However, there is a plan to implement the recommendation suggested by the auditors with respect to the de-anonymization of Witnet nodes.


## 8. Bad Implementation of ecAdd algorithm

State: FIXED

### Recommendations

- Check the value of Y in order to detect whether it would return an infinity point or not.
- Perform single tests to check all possible exceptions that can be produced by the tested functions.
- Perform all unit tests that carry out official versions of the implemented standard.

### Mitigation

The recommendation of checking the value of Y was implemented as:

```solidity
if (_x1 == _x2) {
    // y1 = -y2 mod p
    if (addmod(_y1, _y2, _pp) == 0) {
        return(0, 0);
    } else {
       (x, y, z) = jacDouble(_x1, _y1, 1, _aa, _pp);
    }
} else {
   (x, y, z) = jacAdd(_x1, _y1, 1, _x2, _y2, 1, _pp);
}
```

However, the library does not check whether the inserted points belong to the curve in order to avoid unnecessary gas costs. In the code documentation it is encouraged that library consumers may use the `isOnCurve()` function to check the aforementioned statement.

Source code available at [PR#18](https://github.com/witnet/elliptic-curve-solidity/pull/18).


## 9. Multiple Integer Overflows

State: FIXED

### Recommendations

- It is advisable to establish the types in an explicit manner, to avoid the assumption that the types are identical and to use an index that could have been overflowed when performing a conversion.
- Choose an integer type used for a variable that is consistent with the functions to be performed or that can hold all possible values of an arithmetic operation.
- Both operands and results of an integer operation should be validated and checked for overflow conditions.
- Additionally, use known and audited libraries such as SafeMath.sol from OpenZeppelin to avoid overflows and mathematical operations issues.

### Mitigations

The suggested recommendations have been applied to the issues pointed out in the security audit. The following table summarizes the actions taken.


| Issue  | Repository | State        |  PR | Comments |
| ---- | ----------------- | ------------ | -------- | -------- |
|  [9.1](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/FastEcMul.sol#L443-L444) | elliptic-curve-solidity | FIXED | [23](https://github.com/witnet/elliptic-curve-solidity/pull/23) | `sqrt` function was removed
| [9.2](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L54-L55)     | witnet-ethereum-bridge | FIXED    | [100](https://github.com/witnet/witnet-ethereum-bridge/pull/100) | check overflow
| [9.3](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/ActiveBridgeSetLib.sol#L166-L167)     | witnet-ethereum-bridge | FIXED    | [100](https://github.com/witnet/witnet-ethereum-bridge/pull/100) | check underflow


## 10. Outdated Compiler Version with Known Vulnerabilities

State: FIXED

### Recommendations

- Update to newer compiler version.
- Unify pragma statement.
- Update possible warning and compiler errors.

### Mitigations

For this issue we understand there two different types of smart contracts: libraries and consumer contracts.

In the case of the libraries, other solidity contracts will import the library and they will be fixing the solidity compiler version to be used. For that reason the approach is to provide a wide range of supported solidity compiler versions (0.5.x versions were left out due to [known critical bugs](https://blog.ethereum.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/) with the `ABIEncoderV2`):

```solidity
pragma solidity >=0.6.0 <0.7.0;
```

In the case of consumer contracts, i.e. contracts that are deployed once, the approach was to fix the solidity compiler version to the latest one at the time of the implementation:

```solidity
pragma solidity 0.6.8;
```

However, after reviewing the smart contracts repositories we found out an issue with the contract `WitnetRequestBoardProxy.sol` which was not using a fixed version. It has been fixed at the [PR#111](https://github.com/witnet/witnet-ethereum-bridge/pull/111).

Additionally, contracts have been update to support solidity from 0.6.0 onwards:

- Included in PR [witnet-ethereum-block-relay#20](https://github.com/witnet/witnet-ethereum-block-relay/pull/20)
- Included in PR [witnet-ethereum-bridge#114](https://github.com/witnet/witnet-ethereum-bridge/pull/114)


## 11. Minor Logic Errors

State: PARTIALLY FIXED

### Recommendations

- To review the logic of the entire code, analyzing that all the methods are correctly implemented and return the expected value.

### Mitigations

The suggested recommendations have been applied to the issues pointed out in the security audit. The following table summarizes the actions taken.


| Issue  | Repository | State        |  PR | Comments |
| ---- | ----------------- | ------------ | -------- | -------- |
|  [11.1](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/WitnetRequestsBoard.sol#L212-L213) | witnet-ethereum-bridge | FIXED | [102](https://github.com/witnet/witnet-ethereum-bridge/pull/102) | check DR is claimed before inclusion
| [11.2](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/WitnetRequestsBoardProxy.sol#L52-L54)     | witnet-ethereum-bridge | FIXED  | [94](https://github.com/witnet/witnet-ethereum-bridge/pull/94) | remove UsingWitnetBytes.sol
| [11.3](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/CBOR.sol#L82-L83)     | witnet-ethereum-bridge | NOT FIXED  | [116](https://github.com/witnet/witnet-ethereum-bridge/pull/116) | For the moment we decided to transfer the responsibility to the client contracts to do a try catch. The decision was taken due to the fact that `try-catch` statements inside a library would force client contracts to upgrade to specific versions. We envision such a change to happen in the future, but for the moment we warn about it in the function itself.


## 12. Owner Change Implementation

State: ASSUMED

### Recommendations

- Implement mechanisms for modifying the contract owner.
- Inherit contracts from OpenZeppelin since these have been previously audited and can facilitate this implementation.

### Mitigations

We acknowledge the usefulness of extensively audited contracts such as OpenZeppelin for having contracts with ownership (e.g. `Ownable`).

However, we opted for a more flexible approach and we followed a *Proxy Pattern*. In our design we have the following dependency of smart contracts:

```
                                          +----------------------------+
                                          |                            |
                                          |       <Controller>         |
                                          |    WitnetRequestsBoard 1   |
                                   +----->+                            |
                                   |      |                            |
+----------------------------+     |      |     (from dr_1 to dr_i)    |
|                            |     |      |                            |
|          <Proxy>           |     |      +----------------------------+
|  WitnetRequestsBoardProxy  +-----+
|                            |     |      +----------------------------+
|                            |     |      |                            |
+----------------------------+     |      |        <Controller>        |
                                   |      |    WitnetRequestsBoard 2   |
                                   +----->+                            |
                                          |                            |
                                          |    (from dr_i+1 onwards)   |
                                          |                            |
                                          +----------------------------+
```

The _Controller_ smart contracts implement the `WitnetRequestsBoardInterface` interface contract and they define the business logic behind the function `isUpgradeable()`, which controls how the proxy contract is upgraded.

This pattern provides a wider functionality to the upgradeability than only ownership transfer, e.g. a new controller may include a governance mechanism to decide if the contract could be upgraded or not.


## 13. Absence of Verifications

State: PARTIALLY FIXED

### Recommendations

- It is recommended to carry out an exhaustive verification of all the errors that the code object of the vulnerability could produce

### Mitigations

The suggested recommendations have been applied to the issues pointed out in the security audit. The following table summarizes the actions taken.

| Issue  | Repository | State        |  PR | Comments |
| ---- | ----------------- | ------------ | -------- | -------- |
| [13.1](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L37-L41), [13.2](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L87-L88) , [13.3](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L104-L111), [13.4](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L120-L131), [13.5](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L137-L148), [13.6](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L154-L165), [13.7](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L171-L182), [13.8](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/WitnetRequestsBoard.sol#L177-L178)| witnet-ethereum-bridge | FIXED  | [97](https://github.com/witnet/witnet-ethereum-bridge/pull/97) | Check cursor index is below data length
|  [13.9](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/UsingWitnet.sol#L76-L77) | witnet-ethereum-bridge | NOT FIXED | None | It is the client contract who should handle the error
| [13.10](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/ActiveBridgeSetLib.sol#L50-L51)     | witnet-ethereum-bridge | FIXED  | [113](https://github.com/witnet/witnet-ethereum-bridge/pull/113) | Moved update Update and Push checks to the ABS library
| [13.11](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/Witnet.sol#L205-L285)     | witnet-ethereum-bridge | FIXED  | [117](https://github.com/witnet/witnet-ethereum-bridge/pull/117) | New requires and checks have been addded.
| [13.12](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/Witnet.sol#L418-L424)     | witnet-ethereum-bridge | NOT FIXED  | None | By definition the function does not handle numbers of more than 3 digits
| [13.13](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/WitnetRequestsBoardProxy.sol#L120-L125)     | witnet-ethereum-bridge | FIXED  | [112](https://github.com/witnet/witnet-ethereum-bridge/pull/112) | Added `require` for checking `ID>0`
| [13.14](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/UsingWitnet.sol#L66-L67)     | witnet-ethereum-bridge | NOT FIXED  | None | We consider the majority of the checks should be done by the WRB, just in case some of them are changed later
| [13.15](https://github.com/witnet/witnet-ethereum-block-relay/blob/a3bf55cc58dd8295d3ac4daed45de48a708823fc/contracts/CentralizedBlockRelay.sol#L156-L157)     | witnet-ethereum-block-relay | NOT FIXED  | None | The insertion of past blocks is allowed by design


## 14. Not Exploitable Reentrancy

State: FIXED

### Recommendations

- Assure all internal state changes are performed before external calls are executed. This is known as the Checks-Effects-Interactions pattern.
- Use a reentrancy lock (ie. OpenZeppelin's ReentrancyGuard).

### Mitigations

The recommendations were followed and all internal state changes are performed before external calls:

```solidity
// Update the state upon which this function depends before the external call
requests[_id].drHash = drHash;
require(
  blockRelay.verifyDrPoi(_poi, _blockHash, _epoch, _index, drOutputHash),
  "Invalid PoI"
);
```

```solidity
// Update the state upon which this function depends before the external call
requests[_id].result = _result;

uint256 resHash = uint256(sha256(abi.encodePacked(requests[_id].drHash, _result)));
require(
  blockRelay.verifyTallyPoi(_poi, _blockHash, _epoch, _index, resHash),      
  "Invalid PoI"
);
```

Source code available at [PR#92](https://github.com/witnet/witnet-ethereum-bridge/pull/92).


## 15. Gas optimizations

State: PARTIALLY FIXED

### Recommendations

- Use the arguments instead of doubling their value with new variables.

### Mitigations

| Issue  | Repository | State        |  PR | Comments |
| ---- | ----------------- | ------------ | -------- | -------- |
|  [15.1](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/EllipticCurve.sol#L46), [15.2](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/EllipticCurve.sol#L152), [15.3](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/EllipticCurve.sol#L340), [15.4](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/EllipticCurve.sol#L378), [15.5](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/EllipticCurve.sol#L386-L387), [15.6](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/FastEcMul.sol#L58-L61), [15.7](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/FastEcMul.sol#L64-L66), [15.8](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/FastEcMul.sol#L384-L389), [15.9](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/FastEcMul.sol#L414-L415) | elliptic-curve-solidity | FIXED | [20](https://github.com/witnet/elliptic-curve-solidity/pull/20) | None
| [15.10](https://github.com/witnet/vrf-solidity/blob/40fd85af6815d55a563d0a4b080584a82ce3e7f8/contracts/VRF.sol#L83-L86), [15.11](https://github.com/witnet/vrf-solidity/blob/40fd85af6815d55a563d0a4b080584a82ce3e7f8/contracts/VRF.sol#L136-L139), [15.12](https://github.com/witnet/vrf-solidity/blob/40fd85af6815d55a563d0a4b080584a82ce3e7f8/contracts/VRF.sol#L238-L240)      | vrf-solidity | FIXED  | [21](https://github.com/witnet/vrf-solidity/pull/21) | None
| [15.13](https://github.com/witnet/witnet-ethereum-block-relay/blob/a3bf55cc58dd8295d3ac4daed45de48a708823fc/contracts/CentralizedBlockRelay)     | witnet-ethereum-block-relay | FIXED  | [15](https://github.com/witnet/witnet-ethereum-block-relay/pull/15) | None
|  [15.14](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L11-L12), [15.15](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/BufferLib.sol#L15-L31), [15.16](https://github.com/witnet/witnet-ethereum-bridge/blob/cf4ffe9434be79ec29079a3fcaf885adfb213cb8/contracts/BufferLib.sol#L54), [15.17](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/CBOR.sol#L295-L296), [15.18](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/ActiveBridgeSetLib.sol#L99), [15.19](https://github.com/witnet/witnet-ethereum-bridge/blob/cf4ffe9434be79ec29079a3fcaf885adfb213cb8/contracts/WitnetRequestsBoard.sol#L75), [15.20](https://github.com/witnet/witnet-ethereum-bridge/blob/cf4ffe9434be79ec29079a3fcaf885adfb213cb8/contracts/WitnetRequestsBoard.sol#L84), [15.21](https://github.com/witnet/witnet-ethereum-bridge/blob/cf4ffe9434be79ec29079a3fcaf885adfb213cb8/contracts/WitnetRequestsBoard.sol#L117), [15-22](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/WitnetRequestsBoard.sol#L146-L149) | witnet-ethereum-bridge | FIXED  | [107](https://github.com/witnet/witnet-ethereum-bridge/pull/107) | None
| [15.23](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/Witnet.sol#L299-L300)     | witnet-ethereum-bridge | NOT FIXED  | None | It is a convention in Witnet that errors are returned as CBOR arrays containing unsigned integers. As the only unsigned integer type currently supported is uint64, we are force to use that.
| [15.24](https://github.com/witnet/witnet-ethereum-bridge/blob/cf4ffe9434be79ec29079a3fcaf885adfb213cb8/contracts/WitnetRequestsBoard.sol#L149)     | witnet-ethereum-bridge | NOT FIXED  | None | Delete requests once their result is read. It is not possible because reading result is public and data would be lost. For the moment we have taken the decision of not fixing this as it would imply some changes in the design, but it is definitely something to consider for the future.
| [15.25](https://github.com/witnet/witnet-ethereum-bridge/blob/aa0583a4db3028cbe6bb480900d425ac12f2cb7e/contracts/Witnet.sol#L422-L423)     | witnet-ethereum-bridge | NOT FIXED  | None | It would be antiergonomic to force the caller to do the uint64 â†’ uint16 trimming, because this is always used on uint64 values because that's the API of our CBOR arrays.


## 16. Comments Specification Mismatch

State: FIXED

### Recommendations

- Review the mentioned comments so that it accurately describes the actual implementation.
- Verify that the software met its specifications and requirements.

### Mitigations

The found issues are wrong or poorly described code comments, which were fixed by following the recommendations.

Code fixes available at:

- [elliptic-curve-solidity#26](https://github.com/witnet/elliptic-curve-solidity/pull/26)
- [vrf-solidity#19](https://github.com/witnet/vrf-solidity/pull/19)
- [witnet-ethereum-bridge#106](https://github.com/witnet/witnet-ethereum-bridge/pull/106)


## 17. Use of experimental features

State: ASSUMED

### Recommendations

- Remove experimental pragma declaration.
- Update solc version.

### Mitigations

This experimental features are a key component to reduce the gas cost and improve the ergonomics of the contracts. Thus, we decided not to take this recommendation into consideration. For instance, the following code takes as input parameter a `Result` structure, which would not be possible without the experimental features.

```solidity

 /**
   * @notice Decode a raw error from a `Result` as a `uint64[]`.
   * @param _result An instance of `Result`.
   * @return The `uint64[]` raw error as decoded from the `Result`.
   */
  function asRawError(Result memory _result) public pure returns(uint64[] memory) {
    require(!_result.success, "Tried to read error code from successful Result");
    return _result.cborValue.decodeUint64Array();
  }
```


## 18 - Solidity Code Readability

State: FIXED

### Recommendations

- Maintain consistent indentation and well-structured coding patterns that everyone in the organization previously agrees upon.
- Write well-documented and easily readable code.
- Verify that the software meets its specifications and requirements.
- Include a clear, accurate and precise comments and documentation.
- Integrate Ethlint during our development process.

### Mitigations

| Issue  | Repository | State        |  PR | Comments |
| ---- | ----------------- | ------------ | -------- | -------- |
|  [18.1](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/FastEcMul.sol#L38-L41), [18.2](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/examples/Secp256k1.sol#L1-L31), [18.3](https://github.com/witnet/elliptic-curve-solidity/blob/7d814018d460849deabc882ef19c254160e06301/contracts/FastEcMul.sol#L457-L459) | elliptic-curve-solidity | FIXED | [27](https://github.com/witnet/elliptic-curve-solidity/pull/27) | None
| [18.4](https://github.com/witnet/vrf-solidity/blob/40fd85af6815d55a563d0a4b080584a82ce3e7f8/contracts/VRF.sol#L32-L37) | vrf-solidity | FIXED  | [16](https://github.com/witnet/vrf-solidity/pull/16) | None
| 
[18.5](https://github.com/witnet/witnet-ethereum-bridge/blob/cf4ffe9434be79ec29079a3fcaf885adfb213cb8/contracts/WitnetRequestsBoardInterface.sol#L35-L37), [18.6](https://github.com/witnet/witnet-ethereum-bridge/blob/cf4ffe9434be79ec29079a3fcaf885adfb213cb8/contracts/WitnetRequestsBoard.sol#L354)| witnet-ethereum-bridge | FIXED  | [104](https://github.com/witnet/witnet-ethereum-bridge/pull/104) | None |


## 19. Provide License for Third-Party Codes

State: FIXED

### Recommendations

- Include third-party codes by package manager
- Include in Witnet project any references/copyright to OpenZeppelin code since are under MIT license. 

### Mitigations

The suggested recommendations have been adopted and can be reviewed in the following commit https://github.com/witnet/witnet-ethereum-bridge/commit/7da160d24603f49652a00623c97b504665418b62.
